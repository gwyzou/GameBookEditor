package org.helmo.gbeditor.infrastructure.database.sql;

import org.helmo.gbeditor.infrastructure.database.IStorage;
import org.helmo.gbeditor.infrastructure.database.exceptions.*;
import org.helmo.gbeditor.infrastructure.dto.DtoAuthor;
import org.helmo.gbeditor.infrastructure.dto.DtoBook;
import org.helmo.gbeditor.infrastructure.mapping.*;
import org.helmo.gbeditor.models.*;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Class that is used to apply basic interaction with data base
 */
public class SqlStorage implements IStorage {
    private transient final Connection connection;
    public static final String CREATE_TABLE_AUTHOR="CREATE TABLE AUTHOR(Id_Author INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,name VARCHAR(50),surname VARCHAR(50))";
    public static final String CREATE_TABLE_BOOK="CREATE TABLE BOOK(Id_Book INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,isbn VARCHAR(13) NOT NULL,title VARCHAR(150),resume VARCHAR(500),isPublished SMALLINT DEFAULT 0,Id_Author INT NOT NULL,FOREIGN KEY(Id_Author) REFERENCES AUTHOR(Id_Author))";
    public static final String CREATE_TABLE_PAGE="CREATE TABLE PAGE(Id_Page INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,pageContent VARCHAR(500),pageNumber INT,Id_Book INT NOT NULL,FOREIGN KEY(Id_Book) REFERENCES BOOK(Id_Book))";
    public static final String CREATE_TABLE_CHOICE= "CREATE TABLE Choice(Id_Choice INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,textChoice VARCHAR(100),Id_Page INT NOT NULL,Id_Page_GoTo INT NOT NULL,FOREIGN KEY(Id_Page) REFERENCES PAGE(Id_Page) ON DELETE CASCADE ,FOREIGN KEY(Id_Page_GoTo) REFERENCES PAGE(Id_Page) ON DELETE CASCADE )";

    /**
     * Assigne a Connection to Use on to interact with Data Base
     * @param con connection used
     */
    public SqlStorage(Connection con) {
        this.connection = con;
    }

    /**
     * Load from DB mapping between each book and it's Id in DB
     * @param userId id of current user
     * @param isPublished boolean (int) representing isPublished in DB
     * @return map of book keys and integer values
     */
    @Override
    public Map<Book,Integer> loadBookListFromMat(int userId, int isPublished){
        Map<Book,Integer> toReturn = new HashMap<>();
        try(PreparedStatement statement = connection.prepareStatement("SELECT * FROM BOOK b JOIN AUTHOR a ON a.Id_Author=b.Id_Author WHERE a.Id_Author = ? AND isPublished =?")){
            statement.setInt(1,userId);
            statement.setInt(2,isPublished);

            try(ResultSet rs=statement.executeQuery()){
                while (rs.next()){
                    toReturn.put(MappingBook.getBook(rs.getString("title"),rs.getString("resume"), MappingIsbn.getISbn(rs.getString("isbn")), MappingAuthor.getAuthor(rs.getString("name"),rs.getString("surname"))),rs.getInt("Id_Book"));
                }
            }
            return toReturn;
        } catch (SQLException e) {
            throw new UnableLoadBook(e);
        }
    }
    /**
     * Load a book with pages and choices from DB
     * @param bookId book to load id
     * @return book
     */
    @Override
    public Book loadFullBook(int bookId){
        Book toReturn = loadPartialBook(bookId);
        if(toReturn!=null){
            toReturn.setPageList(loadChoices(loadPageMapping(bookId)));
        }
        return toReturn;
    }
    private Book loadPartialBook(int bookId){
        try(PreparedStatement statement = connection.prepareStatement("SELECT * FROM BOOK b JOIN AUTHOR a ON a.Id_Author=b.Id_Author WHERE Id_Book =?")) {
            statement.setInt(1, bookId);
            try(ResultSet rs = statement.executeQuery()){
                if (rs.next()){
                    return MappingBook.getBook(rs.getString("title"),rs.getString("resume"),MappingIsbn.getISbn(rs.getString("isbn")),MappingAuthor.getAuthor(rs.getString("name"),rs.getString("surname")));
                }
                return null;
            }
        }catch (SQLException e){
            throw new UnableLoadBook(e);
        }
    }
    private Map<Integer,Page> loadPageMapping(int bookId){
        Map<Integer,Page> toReturn = new HashMap<>();
        try(PreparedStatement statement = connection.prepareStatement("SELECT * FROM PAGE WHERE Id_Book = ?")){
            statement.setInt(1,bookId);
            try(ResultSet rs = statement.executeQuery()){
                while (rs.next()){
                    toReturn.put(rs.getInt("Id_Page"), MappingPage.getPage(rs.getString("pageContent"),rs.getInt("pageNumber"),null));
                }
                return  toReturn;
            }
        }catch (SQLException e){
            throw new UnableLoadBook(e);
        }
    }
    private List<Page> loadChoices(Map<Integer,Page> pageMap){
        try(PreparedStatement statement = connection.prepareStatement("SELECT textChoice,Id_Page_GoTo FROM CHOICE WHERE Id_Page = ? ")){
            return getPagesChoices(pageMap, statement);
        }catch (SQLException e){
            throw new UnableLoadBook(e);
        }
    }

    private List<Page> getPagesChoices(Map<Integer, Page> pageMap, PreparedStatement statement) throws SQLException {
        for(int idPage : pageMap.keySet()){
            statement.setInt(1,idPage);
            try(ResultSet rs = statement.executeQuery()){
                while (rs.next()){
                    Page current = pageMap.get(idPage);
                    current.addLink(MappingChoice.getChoice(pageMap.get(rs.getInt("Id_Page_GoTo")),rs.getString("textChoice")));
                }
            }
        }
        return new ArrayList<>(pageMap.values());
    }

    /**
     * Get Id of author id DB
     * @param author current Author to lookup
     * @return Id
     */
    @Override
    public int getMat(Author author){
        var dto = MappingAuthor.authorToDto(author);
        try (PreparedStatement statement = connection.prepareStatement("SELECT Id_Author FROM AUTHOR WHERE name = ? and surname =?")) {
            statement.setString(1,dto.getName());
            statement.setString(2, dto.getSurname());
            try(ResultSet resultSet = statement.executeQuery()){
                if(resultSet.next()){
                    return resultSet.getInt(1);
                }else{
                    return addNewAuthor(dto);
                }
            }
        } catch (SQLException e) {
            throw new UnableGetAuthorDataException(e);
        }
    }
    private int addNewAuthor(DtoAuthor author){
        try(PreparedStatement statement=connection.prepareStatement("INSERT INTO AUTHOR(name,surname) VALUES(?,?)",
                Statement.RETURN_GENERATED_KEYS)){
                statement.setString(1,author.getName());
                statement.setString(2, author.getSurname());
                statement.executeUpdate();
                try(ResultSet generatedKeys = statement.getGeneratedKeys()){
                    if(generatedKeys.next()) {
                        return generatedKeys.getInt(1);
                    }
                    return -1;
                }

        } catch (SQLException e) {
            throw new UnableInsertNewAuthorException(e);
        }
    }

    /**
     * switch between add new book and edit existing book in db
     * @param idBook if new book -1 else id of the book to edit
     * @param from current data to upload
     * @param userID current user
     * @return id of uploaded book or -1 if already exist
     */
    @Override
    public int addOrUpdateBook(int idBook, Book from, int userID){
        if(idBook>0){
            editBook(idBook,from);
            return -1;
        }else{
            return addNewBook(from,userID);
        }

    }
    private void editBook(int idBook, Book book){

        try(PreparedStatement statementPrimaryData=connection.prepareStatement("UPDATE BOOK SET isbn = ? , title = ? , resume = ? WHERE Id_Book = ? ");
        PreparedStatement statementDeletePage=connection.prepareStatement("DELETE FROM PAGE WHERE Id_Book=?");
        PreparedStatement statementAddPages=connection.prepareStatement("INSERT INTO PAGE (pageContent,pageNumber,Id_Book) VALUES (?,?,?)",Statement.RETURN_GENERATED_KEYS);
        PreparedStatement statementAddChoices=connection.prepareStatement("INSERT INTO CHOICE(textChoice,Id_Page,Id_Page_GoTO) VALUES (?,?,?)")){

            connection.setAutoCommit(false);
            editBookPreparedStmt(idBook, book,new ArrayList<>(List.of(new PreparedStatement[]{statementPrimaryData, statementDeletePage, statementAddPages, statementAddChoices})));
            connection.commit();

        }catch (SQLException ex){
            tryRollBack(connection);
            throw new UnableSetupException(ex);
        }finally {
            tryAutoCommit(connection);
        }
    }

    private void editBookPreparedStmt(int idBook, Book book, List<PreparedStatement> preparedStatements) throws SQLException {
        editPrimaryDataBook(idBook, MappingBook.bookToDto(book), preparedStatements.get(0));
        deletePages(idBook, preparedStatements.get(1));
        Map<Page,Integer> pageMap=addPages(book, idBook, preparedStatements.get(2));
        addChoices(book, preparedStatements.get(3),pageMap);
    }

    private void tryRollBack(Connection connection){
        try {
            connection.rollback();
        } catch (SQLException e) {
            throw new UnableToRollBackException(e);
        }
    }
    private void tryAutoCommit(Connection connection){
        try {
            connection.setAutoCommit(true); //Active la gestion automatique des transactions
        } catch(SQLException ex) {
            throw new TransactionNotSupportedException(ex);
        }
    }
    private void editPrimaryDataBook(int idBook, DtoBook book,PreparedStatement statement) throws SQLException {
            statement.setString(1, book.getIsbn());
            statement.setString(2, book.getTitle());
            statement.setString(3, book.getResume());
            statement.setInt(4, idBook);

            statement.executeUpdate();
    }
    private void deletePages(int idBook,PreparedStatement statement) throws SQLException {
        statement.setInt(1,idBook);
        statement.executeUpdate();
    }

    private int addNewBook(Book book,int userID){
        int idBook;
        try(PreparedStatement statementAddBook=connection.prepareStatement("INSERT INTO BOOK(isbn,title,resume,Id_Author) VALUES(?,?,?,?)",Statement.RETURN_GENERATED_KEYS);
            PreparedStatement statementAddPages=connection.prepareStatement("INSERT INTO PAGE (pageContent,pageNumber,Id_Book) VALUES (?,?,?)",Statement.RETURN_GENERATED_KEYS);
            PreparedStatement statementAddChoices=connection.prepareStatement("INSERT INTO CHOICE(textChoice,Id_Page,Id_Page_GoTO) VALUES (?,?,?)")){

            connection.setAutoCommit(false);
            idBook=addBookPrimaryData(MappingBook.bookToDto(book),userID,statementAddBook);
            Map<Page,Integer> pageMap=addPages(book,idBook,statementAddPages);
            addChoices(book,statementAddChoices,pageMap);
            connection.commit();

        }catch (SQLException ex){
            tryRollBack(connection);
            throw new UnableSetupException(ex);
        }finally {
            tryAutoCommit(connection);
        }

        return idBook;
    }
    private int addBookPrimaryData(DtoBook book,int userID,PreparedStatement statement) throws SQLException {
            statement.setString(1,book.getIsbn());
            statement.setString(2, book.getTitle());
            statement.setString(3, book.getResume());
            statement.setInt(4, userID);

            statement.executeUpdate();
            try(ResultSet generatedKeys = statement.getGeneratedKeys()){
                if(generatedKeys.next()) {
                    return generatedKeys.getInt(1);
                }
                return -1;
            }
    }
    private Map<Page, Integer> addPages(Book book, int bookId, PreparedStatement statement) throws SQLException {
        Map<Page,Integer> pageMap=new HashMap<>();
        for (Page element : book.getPageList()) {
            statement.setString(1, element.getText());
            statement.setInt(2, element.getPageNbr());
            statement.setInt(3,bookId);

            statement.executeUpdate();
            try(ResultSet generatedKeys = statement.getGeneratedKeys()){
                if(generatedKeys.next()) {
                    pageMap.put(element,generatedKeys.getInt(1)) ;
                }
            }
        }
        return pageMap;
    }
    private void addChoices(Book book, PreparedStatement statement, Map<Page, Integer> pageMap) throws SQLException {
        for(Page page:book.getPageList()){
            for(Choice choice : page.getChoices()){
                int goTo = pageMap.get(choice.getPageChoice());
                statement.setString(1, choice.getTextChoice());
                statement.setInt(2, pageMap.get(page));
                statement.setInt(3, goTo);

                statement.executeUpdate();
            }
        }
    }

    /**
     * Set IsPulished to 1 in DB to where @param = idBook
     * @param idBook book to publish id
     */
    @Override
    public void publishBook(int idBook){
        try(PreparedStatement statement=connection.prepareStatement("UPDATE BOOK SET isPublished= ? WHERE Id_Book = ? ")){
            statement.setInt(1,1);
            statement.setInt(2,idBook);
            statement.executeUpdate();
        }catch (SQLException e){
            throw new UnablePublishBook(e);
        }
    }

    /**
     * setup bd for testing
     */
    public void setup(){
        try (Statement createStatement = connection.createStatement()) {
            createStatement.executeUpdate(CREATE_TABLE_AUTHOR);
            createStatement.executeUpdate(CREATE_TABLE_BOOK);
            createStatement.executeUpdate(CREATE_TABLE_PAGE);
            createStatement.executeUpdate(CREATE_TABLE_CHOICE);
        } catch (SQLException e) {
            throw new UnableSetupException(e);
        }
    }

    /**
     * empty Bd after test
     */
    public void tearDown() {
        try (Statement createStatement = connection.createStatement()) {
            createStatement.executeUpdate("DROP TABLE CHOICE");
            createStatement.executeUpdate("DROP TABLE PAGE");
            createStatement.executeUpdate("DROP TABLE BOOK");
            createStatement.executeUpdate("DROP TABLE AUTHOR");

        } catch (SQLException e) {
            throw new UnableTearDownException(e);
        }
    }

    /**
     * override of close methode implemented by closeable interface
     * @throws Exception
     */
    @Override
    public void close() throws Exception {
        try {
            connection.close();
        } catch (SQLException ex) {
            throw new DisconnectionFailedException(ex);
        }
    }
}
